{"version":3,"file":"minimal.js","sources":["../src/util.ts","../src/events.ts","../src/meta-events.ts","../src/emit.ts","../src/unsubscribe.ts"],"sourcesContent":["import { TEventMap } from './types';\n\n/**\n * Maps object values by their keys into a new object\n *\n * Generaly equivalent to `Array.prototype.map()`\n */\nexport const mapObject = <T extends object, R>(\n  obj: T,\n  value: (key: keyof T) => R\n) => (\n  <Array<keyof T>>\n  [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)]\n).reduce((newObj, key) => (\n  newObj[key] = value(key), newObj\n), <Record<keyof T, R>> {});\n\nexport type TDoAction<P extends any[] = any[], R = void> = <M extends TEventMap>(\n  eventMap: M\n) => <E extends keyof M>(\n  event: E\n) => (...args: P) => R;\n","import { mapObject } from './util';\nimport { TEventMap, TEventSignatures } from './types';\n\n/**\n * Creates an event collection based on handler templates\n *\n * @param events - an object with default handlers for events\n */\nexport const eventMap = <Events extends TEventSignatures>(\n  events: Events\n) => <TEventMap<Events>> mapObject(\n  events,\n  // Actually faster than `new Map([[events[event], () => {}]])`\n  // see https://jsperf.com/map-constructor-vs-set/2\n  // This might be due to the initialization of iterators in the constructor (https://tc39.es/ecma262/#sec-map-iterable),\n  // whereas no iterators are used in the `set` method (https://tc39.es/ecma262/#sec-map.prototype.set).\n  event => new Map().set(events[event], () => {\n    /* make it impossible to unsubscribe from within the default handler */\n  })\n);\n","import { eventMap } from './events';\nimport { TEventMap, TEventHandler } from './types';\n\nexport const enum EMetaEvents {\n  /**\n   * Emitted when any event is emitted, except itself\n   */\n  EMIT = 'EMIT',\n\n  /**\n   * Emitted when any event is subscribed to, except itself\n   */\n  SUBSCRIBE = 'SUBSCRIBE',\n\n  /**\n   * Emitted when any event is unsubscribed from, except itself\n   */\n  UNSUBSCRIBE = 'UNSUBSCRIBE',\n}\n\nexport const metaEvents = eventMap({\n  [EMetaEvents.EMIT](_, _map: TEventMap, _event: keyof TEventMap, _args: any[]) {},\n  [EMetaEvents.SUBSCRIBE](_, _map: TEventMap, _event: keyof TEventMap, _handler: TEventHandler) {},\n  [EMetaEvents.UNSUBSCRIBE](_, _map: TEventMap, _event: keyof TEventMap, _handler: TEventHandler) {},\n});\n\nexport type TMetaEvents = typeof metaEvents;\n","import { TMetaEvents, metaEvents, EMetaEvents } from './meta-events';\nimport { TEventMap, THandlerOf, TLastParams } from './types';\n\n/**\n * Event-emitter factory creator\n *\n * Creates an emitter factory for specific events.\n *\n * @param eventMap - an event collection to create an emitter for\n */\nexport const emit = <M extends TEventMap>(\n  eventMap: M\n) =>\n/**\n * Emitter factory for a specific event collection\n *\n * Creates an emitter for a specific event\n *\n * @param event - the name of the event to emit\n */\n<E extends keyof M>(event: E) =>\n/**\n * Emits an event with proper arguments\n */\n(...args: TLastParams<THandlerOf<M, E>>): Promise<Array<ReturnType<THandlerOf<M, E>>>> => (\n  emitMeta(EMetaEvents.EMIT)(eventMap, event, args),\n  Promise.all(\n    [...(eventMap[event] || [])].map(\n      ([handler, unsubscribe]) => handler\n        && handler({ event, unsubscribe }, ...args)\n    ) as Array<ReturnType<THandlerOf<M, E>>>\n  )\n);\n\n/**\n * Emits a meta-event\n *\n * @param event - a meta-event to emit\n */\nexport const emitMeta = <E extends EMetaEvents>(event: E) => (\n  ...args: TLastParams<THandlerOf<TMetaEvents, E>>\n): Promise<void[]> => args[0] !== metaEvents\n  ? emit(metaEvents)(event)(...args)\n  : Promise.resolve([]);\n","import { emitMeta } from './emit';\nimport { TEventMap, TUnsubscribeHandlers } from './types';\nimport { EMetaEvents } from './meta-events';\n\nexport const unsubscribe = <M extends TEventMap>(\n  eventMap: M\n) => <E extends keyof M>(\n  event: E\n): TUnsubscribeHandlers<M, E> => (\n  ...handlers\n) => {\n  if (event in eventMap) for (\n    const h of handlers.length > 0\n      ? handlers\n      : eventMap[event].keys()\n  ) // Emit meta-event (ignore promise)\n    emitMeta(EMetaEvents.UNSUBSCRIBE)(eventMap, event, h),\n    eventMap[event].delete(h);\n};\n\nexport const off = unsubscribe;\n"],"names":["events","obj","value","metaEvents","_","_map","_event","_args","_handler","event","Map","set","Object","keys","getOwnPropertySymbols","reduce","newObj","key","emit","eventMap","args","emitMeta","Promise","all","_toConsumableArray","map","handler","unsubscribe","resolve","handlers","length","h","off"],"mappings":"0oCAOO,MCELA,EDDAC,EACAC,EEWWC,0BACQC,EAAGC,EAAiBC,EAAyBC,+BACxCH,EAAGC,EAAiBC,EAAyBE,iCAC3CJ,EAAGC,EAAiBC,EAAyBE,MFfvEP,ECCAD,IDAAE,ECOA,SAAAO,UAAS,IAAIC,KAAMC,IAAIX,EAAOS,GAAQ,eDJtC,YAAIG,OAAOC,KAAKZ,MAASW,OAAOE,sBAAsBb,KACtDc,OAAO,SAACC,EAAQC,UAChBD,EAAOC,GAAOf,EAAMe,GAAMD,GACJ,KGLXE,EAAO,SAClBC,UASF,SAAoBV,UAIpB,sCAAIW,2BAAAA,yBACFC,SAAAA,CAA2BF,EAAUV,EAAOW,GAC5CE,QAAQC,IACNC,EAAKL,EAASV,IAAU,IAAKgB,IAC3B,yBAAEC,OAASC,cAAiBD,GACvBA,gBAAQ,CAAEjB,MAAAA,EAAOkB,YAAAA,WAAkBP,UAUjCC,EAAW,SAAwBZ,UAAa,6DAE3BN,EAC9Be,EAAKf,EAALe,CAAiBT,2BACjBa,QAAQM,QAAQ,MCvCPD,EAAc,SACzBR,UACG,SACHV,UAC+B,sCAC5BoB,2BAAAA,qBAECpB,KAASU,2CACAU,EAASC,OAAS,EACzBD,EACAV,EAASV,GAAOI,4DAFdkB,UAINV,gBAAAA,CAAkCF,EAAUV,EAAOsB,GACnDZ,EAASV,UAAcsB,2FAGdC,EAAML"}