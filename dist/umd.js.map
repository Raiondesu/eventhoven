{"version":3,"file":"umd.js","sources":["../src/util.ts","../src/events.ts","../src/meta-events.ts","../src/emit.ts","../src/unsubscribe.ts","../src/subscribe.ts","../src/collections.ts","../src/all.ts","../src/debug.ts","../src/once.ts","../src/wait.ts","../src/class.ts"],"sourcesContent":["import { TEventMap } from './types';\n\n/**\n * Maps object values by their keys into a new object\n *\n * Generaly equivalent to `Array.prototype.map()`\n */\nexport const mapObject = <T extends object, R>(\n  obj: T,\n  value: (key: keyof T) => R\n) => (\n  <Array<keyof T>>\n  [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)]\n).reduce((newObj, key) => (\n  newObj[key] = value(key), newObj\n), <Record<keyof T, R>> {});\n\nexport type TDoAction<P extends any[] = any[], R = void> = <M extends TEventMap>(\n  eventMap: M\n) => <E extends keyof M>(\n  event: E\n) => (...args: P) => R;\n","import { mapObject } from './util';\nimport { TEventMap, TEventSignatures } from './types';\n\n/**\n * Creates an event collection based on handler templates\n *\n * @param events - an object with default handlers for events\n */\nexport const eventMap = <Events extends TEventSignatures>(\n  events: Events\n) => <TEventMap<Events>> mapObject(\n  events,\n  // Actually faster than `new Map([[events[event], () => {}]])`\n  // see https://jsperf.com/map-constructor-vs-set/2\n  // This might be due to the initialization of iterators in the constructor (https://tc39.es/ecma262/#sec-map-iterable),\n  // whereas no iterators are used in the `set` method (https://tc39.es/ecma262/#sec-map.prototype.set).\n  event => new Map().set(events[event], () => {\n    /* make it impossible to unsubscribe from within the default handler */\n  })\n);\n","import { eventMap } from './events';\nimport { TEventMap, TEventHandler } from './types';\n\nexport const enum EMetaEvents {\n  /**\n   * Emitted when any event is emitted, except itself\n   */\n  EMIT = 'EMIT',\n\n  /**\n   * Emitted when any event is subscribed to, except itself\n   */\n  SUBSCRIBE = 'SUBSCRIBE',\n\n  /**\n   * Emitted when any event is unsubscribed from, except itself\n   */\n  UNSUBSCRIBE = 'UNSUBSCRIBE',\n}\n\nexport const metaEvents = eventMap({\n  [EMetaEvents.EMIT](_, _map: TEventMap, _event: keyof TEventMap, _args: any[]) {},\n  [EMetaEvents.SUBSCRIBE](_, _map: TEventMap, _event: keyof TEventMap, _handler: TEventHandler) {},\n  [EMetaEvents.UNSUBSCRIBE](_, _map: TEventMap, _event: keyof TEventMap, _handler: TEventHandler) {},\n});\n\nexport type TMetaEvents = typeof metaEvents;\n","import { TMetaEvents, metaEvents, EMetaEvents } from './meta-events';\nimport { TEventMap, THandlerOf, TLastParams } from './types';\n\n/**\n * Event-emitter factory creator\n *\n * Creates an emitter factory for specific events.\n *\n * @param eventMap - an event collection to create an emitter for\n */\nexport const emit = <M extends TEventMap>(\n  eventMap: M\n) =>\n/**\n * Emitter factory for a specific event collection\n *\n * Creates an emitter for a specific event\n *\n * @param event - the name of the event to emit\n */\n<E extends keyof M>(event: E) =>\n/**\n * Emits an event with proper arguments\n */\n(...args: TLastParams<THandlerOf<M, E>>): Promise<Array<ReturnType<THandlerOf<M, E>>>> => (\n  emitMeta(EMetaEvents.EMIT)(eventMap, event, args),\n  Promise.all(\n    [...(eventMap[event] || [])].map(\n      ([handler, unsubscribe]) => handler\n        && handler({ event, unsubscribe }, ...args)\n    ) as Array<ReturnType<THandlerOf<M, E>>>\n  )\n);\n\n/**\n * Emits a meta-event\n *\n * @param event - a meta-event to emit\n */\nexport const emitMeta = <E extends EMetaEvents>(event: E) => (\n  ...args: TLastParams<THandlerOf<TMetaEvents, E>>\n): Promise<void[]> => args[0] !== metaEvents\n  ? emit(metaEvents)(event)(...args)\n  : Promise.resolve([]);\n","import { emitMeta } from './emit';\nimport { TEventMap, TUnsubscribeHandlers } from './types';\nimport { EMetaEvents } from './meta-events';\n\nexport const unsubscribe = <M extends TEventMap>(\n  eventMap: M\n) => <E extends keyof M>(\n  event: E\n): TUnsubscribeHandlers<M, E> => (\n  ...handlers\n) => {\n  if (event in eventMap) for (\n    const h of handlers.length > 0\n      ? handlers\n      : eventMap[event].keys()\n  ) // Emit meta-event (ignore promise)\n    emitMeta(EMetaEvents.UNSUBSCRIBE)(eventMap, event, h),\n    eventMap[event].delete(h);\n};\n\nexport const off = unsubscribe;\n","import { unsubscribe } from './unsubscribe';\nimport { emitMeta } from './emit';\nimport { TEventMap, THandlerOf, TUnsubscribe } from './types';\nimport { EMetaEvents } from './meta-events';\n\nexport type TSubscriber<M extends TEventMap, N extends keyof M> = {\n  (handler: THandlerOf<M, N>): TUnsubscribe<N>;\n  (...handlers: Array<THandlerOf<M, N>>): TUnsubscribe<N>;\n};\n\ntype TSubscriberFactory<M extends TEventMap> = {\n  <E extends keyof M>(event: E): TSubscriber<M, E>;\n};\n\n/**\n * A subscriber factory\n *\n * @param eventMap - an event collection to subscribe to\n * @returns a function that subscribes handlers to a given event in a collection\n */\nexport const subscribe = <M extends TEventMap>(\n  eventMap: M\n): TSubscriberFactory<M> => <E extends keyof M>(\n  event: E\n): TSubscriber<M, E> => {\n  const unsub = (\n    ...handlers: Array<THandlerOf<M, E>>\n  ) => () => unsubscribe(eventMap)(event)(...handlers);\n\n  return (...handlers: Array<THandlerOf<M, E>>) => unsub(\n    ...handlers.map(handler => (\n      // Emit meta-event (ignore promise)\n      emitMeta(EMetaEvents.SUBSCRIBE)(eventMap, event, handler),\n      event in eventMap && eventMap[event].set(handler, unsub(handler)),\n      handler\n    ))\n  );\n};\n\nexport const on = subscribe;\n","import { mapObject, TDoAction } from './util';\nimport { emit } from './emit';\nimport { subscribe } from './subscribe';\nimport { unsubscribe } from './unsubscribe';\nimport { TEventMap, THandlerOf, TEventHandler, TLastParams } from './types';\n\ntype TEventHandlerFrom<H extends TEventHandler> = (...args: TLastParams<H>) => Promise<Array<ReturnType<H>>>;\n\nexport type THandlerMap<M extends TEventMap> = {\n  [event in keyof M]: TEventHandlerFrom<THandlerOf<M, event>>;\n};\n\nexport type THandlersMap<M extends TEventMap> = {\n  [event in keyof M]: (...handlers: THandlerOf<M, event>[]) => void;\n};\n\nexport type TEventCollection<M extends TEventMap> = {\n  emit: THandlerMap<M>;\n  subscribe: THandlersMap<M>;\n  unsubscribe: THandlersMap<M>;\n};\n\nconst createCollection = <A extends TDoAction>(\n  action: A\n) => <M extends TEventMap>(\n  eventMap: M\n) => mapObject(\n  eventMap,\n  action(eventMap)\n);\n\n// TODO - remove type-casting\n\n/**\n * Create a namespaced event emitter collection\n * with each property of the collection corresponding to emitting a particular event\n *\n * @param eventMap - event collection to emit events for\n */\nexport const emitCollection = <{\n  <M extends TEventMap>(eventMap: M): THandlerMap<M>;\n}> createCollection(emit as TDoAction);\n\ntype THandlersMapper = {\n  <M extends TEventMap>(eventMap: M): THandlersMap<M>;\n};\n\n/**\n * Create a namespaced event subscriber collection\n * with each property of the collection corresponding to subscribing to a particular event\n *\n * @param eventMap - event collection to subscribe handlers for\n */\nexport const subscribeCollection = <THandlersMapper> createCollection(subscribe);\n\n/**\n * Create a namespaced event unsubscriber collection\n * with each property of the collection corresponding to unsubscribing from a particular event\n *\n * @param eventMap - event collection to unsubscribe handlers from\n */\nexport const unsubscribeCollection = <THandlersMapper> createCollection(unsubscribe);\n\n/**\n * Creates an OOP-style event collection\n *\n * @param eventMap - event map to create a collection from\n */\nexport const eventCollection = <M extends TEventMap>(\n  eventMap: M\n): TEventCollection<M> => ({\n  emit: emitCollection(eventMap),\n  subscribe: subscribeCollection(eventMap),\n  unsubscribe: unsubscribeCollection(eventMap),\n});\n","import { mapObject, TDoAction } from './util';\nimport { TEventMap, THandlerOf, TLastParams } from './types';\nimport { emit } from './emit';\nimport { subscribe } from './subscribe';\nimport { unsubscribe } from './unsubscribe';\n\n/**\n * A `do`-er factory\n *\n * Applies a specified action for all events in a collection\n *\n * @param action - an action to apply\n */\nconst doForAll = <A extends TDoAction>(\n  action: A\n) => <M extends TEventMap>(\n  eventMap: M\n) => (\n  ...args: A extends TDoAction<infer P> ? P : any[]\n) => {\n  mapObject(eventMap, key => action(eventMap)(key)(...args));\n};\n\ntype THandlersForAll = {\n  <M extends TEventMap>(eventMap: M): {\n    (handler: THandlerOf<M>): void;\n    (...handlers: THandlerOf<M>[]): void;\n  };\n};\n\ntype TEventParamsMap<M extends TEventMap> = {\n  [name in keyof M]: TLastParams<THandlerOf<M, name>>;\n};\n\n/**\n * Emit all events for a given event collection\n *\n * @param eventMap - event collection to emit events for\n *\n * @returns a function that emits all events from a collection with given arguments\n */\nexport const emitAll = <M extends TEventMap>(\n  eventMap: M\n) => (\n  eventArgs: TEventParamsMap<M>\n) => mapObject<M, Promise<unknown[]>>(\n  eventMap,\n  name => emit(eventMap)(name)(...eventArgs[name])\n);\n\n/**\n * A subscriber factory for all events of a given collection\n *\n * @param eventMap - an event collection to subscribe to\n * @returns a function that subscribes handlers to all events in the given event collection\n */\nexport const subscribeToAll = <THandlersForAll> doForAll(subscribe);\nexport const onAll = subscribeToAll;\n\nexport const unsubscribeFromAll = <THandlersForAll> doForAll(unsubscribe);\nexport const offAll = unsubscribeFromAll;\n","import { metaEvents, TMetaEvents } from './meta-events';\nimport { onAll, offAll } from './all';\nimport { TEventMap, TEventContext, TEventHandler } from './types';\n\nconst onMeta = onAll(metaEvents);\nconst offMeta = offAll(metaEvents);\n\n/**\n * Default logging function\n */\nconst log = (\n  { event }: TEventContext<TMetaEvents>,\n  map: TEventMap,\n  eventName: keyof TEventMap,\n  argsOrHandler: any[] | TEventHandler\n) => console.log(\n  // tslint:disable-next-line: no-magic-numbers - because these *are* magic\n  new Date().toJSON().substr(14, 9),\n\n  `[${event} \"${String(eventName)}\"${eventName in map ? '' : ' (INVALID)'}] -`,\n\n  argsOrHandler\n);\n\nexport type TLogHandler = typeof log;\n\n/**\n * Custom debugger factory\n *\n * Creates a function that toggles debug mode using the provided `logEvent` function.\n *\n * @param logEvent - a custom logging function\n * * Overrides the default\n * * When debug mode is enabled - the `logEvent` function is called for all meta-events\n *\n * @returns a debug toggler function\n */\nexport const customDebug = (logEvent: TLogHandler) =>\n/**\n * Enable or disable the debug mode.\n *\n * @param enable - whether to enable the debug mode\n * * `true` to enable, `false` to disable\n */\n(enable: boolean) => (\n  enable ? onMeta : offMeta\n)(logEvent);\n\n/**\n * Enable or disable the debug mode.\n *\n * When debug mode is enabled - every event is logged to the console\n * with a timestamp and other information.\n *\n * @param enable - whether to enable the debug mode\n * * `true` to enable, `false` to disable\n */\nexport const debug = customDebug(log);\n","import { TEventMap, THandlerOf, TEventContext, TLastParams } from './types';\n\n/**\n * Makes a handler to be called only once,\n * by unsubscribing it right at its execution\n *\n * @param handler - a handler to transform\n *\n * @returns a transformed handler\n */\nexport const once = <\n  M extends TEventMap,\n  E extends keyof M\n>(handler: THandlerOf<M, E>) => <THandlerOf<M, E>> ((\n  _: TEventContext<M>,\n  ...args: TLastParams<THandlerOf<M, E>>\n) => (_.unsubscribe(), handler(_, ...args)));\n","import { subscribe } from './subscribe';\nimport { TEventMap, THandlerOf, TLastParams } from './types';\nimport { once } from './once';\n\n/**\n * Creates an event waiter for an event-map\n *\n * @param eventMap - an event-map to create a waiter for\n * @returns an event waiter\n */\nexport const wait = <M extends TEventMap>(\n  eventMap: M\n) =>\n/**\n * Wait for event to be emitted\n *\n * @param event - an event to wait for\n * @returns a promise that resolves as soon as the described event is emitted\n */\n<E extends keyof M>(\n  event: E\n) => new Promise<TLastParams<THandlerOf<M, E>>>(resolve =>\n  subscribe(eventMap)(event)(\n    once(((_, ...args: TLastParams<THandlerOf<M, E>>) => resolve(args)) as THandlerOf<M, E>)\n  )\n);\n\n/**\n * Creates an event waiter factory for an event-map\n *\n * Same as `wait`, but in-harmony with the other methods\n * due to having an arity of 3.\n *\n * @param eventMap - an event-map to create a waiter for\n * @returns an event waiter factory\n */\nexport const harmonicWait = <M extends TEventMap>(\n  eventMap: M\n) =>\n/**\n * Wait for event to be emitted\n *\n * @param event - an event to wait for\n * @returns an event waiter that returns a promise\n */\n<E extends keyof M>(\n  event: E\n) =>\n/**\n * Wait for event to be emitted\n *\n * @returns a promise that resolves as soon as the described event is emitted\n */\n() => wait(eventMap)(event);\n","import { TEventSignatures, TEventMap } from './types';\nimport { TEventCollection, eventCollection } from './collections';\nimport { eventMap } from './events';\nimport { emit } from './emit';\nimport { on } from './subscribe';\nimport { off } from './unsubscribe';\n\nexport class Eventhoven<T extends TEventSignatures> {\n  public readonly map: TEventMap<T>;\n\n  constructor(\n    protected events: T\n  ) {\n    this.map = eventMap(events);\n\n    const collection = eventCollection(this.map);\n\n    this.emit = collection.emit;\n    this.on = collection.subscribe;\n    this.off = collection.unsubscribe;\n  }\n\n  public readonly emit: TEventCollection<TEventMap<T>>['emit'];\n  public readonly on: TEventCollection<TEventMap<T>>['subscribe'];\n  public readonly off: TEventCollection<TEventMap<T>>['unsubscribe'];\n\n  public static readonly emit = emit;\n  public static readonly on = on;\n  public static readonly off = off;\n}\n\n"],"names":["mapObject","obj","value","Object","keys","getOwnPropertySymbols","reduce","newObj","key","eventMap","events","event","Map","set","metaEvents","_","_map","_event","_args","_handler","emit","args","emitMeta","Promise","all","_toConsumableArray","map","handler","unsubscribe","resolve","handlers","length","h","off","subscribe","unsub","on","createCollection","action","emitCollection","subscribeCollection","unsubscribeCollection","eventCollection","doForAll","subscribeToAll","onAll","unsubscribeFromAll","offAll","onMeta","offMeta","customDebug","logEvent","enable","debug","eventName","argsOrHandler","console","log","Date","toJSON","substr","String","once","wait","Eventhoven","collection","this","eventArgs","name"],"mappings":"0oCAOO,MAAMA,EAAY,SACvBC,EACAC,SAGA,YAAIC,OAAOC,KAAKH,MAASE,OAAOE,sBAAsBJ,KACtDK,OAAO,SAACC,EAAQC,UAChBD,EAAOC,GAAON,EAAMM,GAAMD,GACJ,KCPXE,EAAW,SACtBC,UACuBV,EACvBU,EAKA,SAAAC,UAAS,IAAIC,KAAMC,IAAIH,EAAOC,GAAQ,iBCI3BG,EAAaL,0BACLM,EAAGC,EAAiBC,EAAyBC,+BACxCH,EAAGC,EAAiBC,EAAyBE,iCAC3CJ,EAAGC,EAAiBC,EAAyBE,UCb5DC,EAAO,SAClBX,UASF,SAAoBE,UAIpB,sCAAIU,2BAAAA,yBACFC,SAAAA,CAA2Bb,EAAUE,EAAOU,GAC5CE,QAAQC,IACNC,EAAKhB,EAASE,IAAU,IAAKe,IAC3B,yBAAEC,OAASC,cAAiBD,GACvBA,gBAAQ,CAAEhB,MAAAA,EAAOiB,YAAAA,WAAkBP,UAUjCC,EAAW,SAAwBX,UAAa,6DAE3BG,EAC9BM,EAAKN,EAALM,CAAiBT,2BACjBY,QAAQM,QAAQ,MCvCPD,EAAc,SACzBnB,UACG,SACHE,UAC+B,sCAC5BmB,2BAAAA,qBAECnB,KAASF,2CACAqB,EAASC,OAAS,EACzBD,EACArB,EAASE,GAAOP,4DAFd4B,UAINV,gBAAAA,CAAkCb,EAAUE,EAAOqB,GACnDvB,EAASE,UAAcqB,2FAGdC,EAAML,ECANM,EAAY,SACvBzB,UAC0B,SAC1BE,OAEMwB,EAAQ,sCACTL,2BAAAA,yBACA,kBAAMF,EAAYnB,EAAZmB,CAAsBjB,gBAAUmB,YAEpC,sCAAIA,2BAAAA,yBAAsCK,iBAC5CL,EAASJ,IAAI,SAAAC,UAEdL,cAAAA,CAAgCb,EAAUE,EAAOgB,GACjDhB,KAASF,GAAYA,EAASE,GAAOE,IAAIc,EAASQ,EAAMR,IACxDA,SAKOS,EAAKF,ECjBZG,EAAmB,SACvBC,UACG,SACH7B,UACGT,EACHS,EACA6B,EAAO7B,MAWI8B,EAEVF,EAAiBjB,GAYPoB,EAAwCH,EAAiBH,GAQzDO,EAA0CJ,EAAiBT,GAO3Dc,EAAkB,SAC7BjC,SACyB,CACzBW,KAAMmB,EAAe9B,GACrByB,UAAWM,EAAoB/B,GAC/BmB,YAAaa,EAAsBhC,KC5D/BkC,EAAW,SACfL,UACG,SACH7B,UACG,sCACAY,2BAAAA,kBAEHrB,EAAUS,EAAU,SAAAD,UAAO8B,EAAO7B,EAAP6B,CAAiB9B,gBAAQa,QAoCzCuB,EAAmCD,EAAST,GAC5CW,EAAQD,EAERE,EAAuCH,EAASf,GAChDmB,EAASD,ECxDhBE,EAASH,EAAM/B,GACfmC,EAAUF,EAAOjC,GAgCVoC,EAAc,SAACC,UAO5B,SAACC,UACCA,EAASJ,EAASC,GAClBE,KAWWE,EAAQH,EA/CT,WAEVxB,EACA4B,EACAC,OAHE5C,IAAAA,aAIC6C,QAAQC,KAEX,IAAIC,MAAOC,SAASC,OAAO,GAAI,cAE3BjD,eAAUkD,OAAOP,eAAcA,KAAa5B,EAAM,GAAK,oBAE3D6B,KCXWO,EAAO,SAGlBnC,UAAkD,SAClDZ,8BACGM,mCAAAA,2BACCN,EAAEa,cAAeD,gBAAQZ,UAAMM,MCNxB0C,EAAO,SAClBtD,UAQF,SACEE,UACG,IAAIY,QAAuC,SAAAM,UAC9CK,EAAUzB,EAAVyB,CAAoBvB,EAApBuB,CACE4B,EAAM,SAAC/C,8BAAMM,mCAAAA,2BAAwCQ,EAAQR,UChBpD2C,EAGX,WACYtD,qHAAAA,OAELgB,IAAMjB,EAASC,OAEduD,EAAavB,EAAgBwB,KAAKxC,UAEnCN,KAAO6C,EAAW7C,UAClBgB,GAAK6B,EAAW/B,eAChBD,IAAMgC,EAAWrC,aAODoC,OAAO5C,EACP4C,KAAK5B,EACL4B,MAAM/B,8DJaR,SACrBxB,UACG,SACH0D,UACGnE,EACHS,EACA,SAAA2D,UAAQhD,EAAKX,EAALW,CAAegD,kBAASD,EAAUC,yFGXhB,SAC1B3D,UAQF,SACEE,UAOF,kBAAMoD,EAAKtD,EAALsD,CAAepD"}