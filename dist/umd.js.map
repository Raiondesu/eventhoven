{"version":3,"file":"umd.js","sources":["../src/util.ts","../src/events.ts","../src/meta-events.ts","../src/emit.ts","../src/unsubscribe.ts","../src/subscribe.ts","../src/collections.ts","../src/wait.ts","../src/debug.ts","../src/once.ts"],"sourcesContent":["import { TEventMap, THandlerOf } from './types';\n\nexport type TDoAction<P extends any[] = any[], R = void> = <M extends TEventMap>(\n  eventMap: M\n) => <E extends keyof M>(\n  event: E\n) => (...args: P) => R;\n\n/**\n * Maps object values by their keys into a new object\n *\n * Generaly equivalent to `Array.prototype.map()`\n */\nexport const mapObject = <T extends object, R>(\n  obj: T,\n  value: (key: keyof T) => R\n) => (\n  <Array<keyof T>>\n  [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)]\n).reduce((newObj, key) => (\n  newObj[key] = value(key), newObj\n), <Record<keyof T, R>> {});\n\n/**\n * A `do`-er factory\n *\n * Applies a specified action for all events in a collection\n *\n * @param action - an action to apply\n */\nexport const doForAll = <A extends TDoAction>(\n  action: A\n) => <M extends TEventMap>(\n  eventMap: M\n) => (\n  ...args: A extends TDoAction<infer P> ? P : any[]\n) => {\n  mapObject(eventMap, key => action(eventMap)(key)(...args));\n};\n\nexport type THandlersForAll = {\n  <M extends TEventMap>(eventMap: M): {\n    (handler: THandlerOf<M>): void;\n    (...handlers: THandlerOf<M>[]): void;\n  };\n};\n","import { mapObject } from './util';\nimport { TEventMap, TEventSignatures } from './types';\n\n/**\n * Creates an event collection based on handler templates\n *\n * @param events - an object with default handlers for events\n */\nexport const eventMap = <Events extends TEventSignatures>(\n  events: Events\n) => <TEventMap<Events>> mapObject(\n  events,\n  event => new Map().set(events[event], () => {\n    /* make it impossible to unsubscribe from the default handler */\n  })\n);\n","import { eventMap } from './events';\nimport { TEventMap, TEventHandler } from './types';\n\nexport const enum EMetaEvents {\n  /**\n   * Emitted when any event is emitted, except itself\n   */\n  EMIT = 'EMIT',\n\n  /**\n   * Emitted when any event is subscribed to, except itself\n   */\n  SUBSCRIBE = 'SUBSCRIBE',\n\n  /**\n   * Emitted when any event is unsubscribed from, except itself\n   */\n  UNSUBSCRIBE = 'UNSUBSCRIBE',\n}\n\nexport const metaEvents = eventMap({\n  [EMetaEvents.EMIT](_, _map: TEventMap, _event: keyof TEventMap, _args: any[]) {},\n  [EMetaEvents.SUBSCRIBE](_, _map: TEventMap, _event: keyof TEventMap, _handler: TEventHandler) {},\n  [EMetaEvents.UNSUBSCRIBE](_, _map: TEventMap, _event: keyof TEventMap, _handler: TEventHandler) {},\n});\n\nexport type TMetaEvents = typeof metaEvents;\n","import { TMetaEvents, metaEvents, EMetaEvents } from './meta-events';\nimport { mapObject } from './util';\nimport { TEventMap, THandlerOf, TLastParams } from './types';\n\n/**\n * Event-emitter factory creator\n *\n * Creates an emitter factory for specific events.\n *\n * @param eventMap - an event collection to create an emitter for\n */\nexport const emit = <M extends TEventMap>(\n  eventMap: M\n) =>\n/**\n * Emitter factory for a specific event collection\n *\n * Creates an emitter for a specific event\n *\n * @param event - the name of the event to emit\n */\n<E extends keyof M>(event: E) =>\n/**\n * Emits an event with proper arguments\n */\n(...args: TLastParams<THandlerOf<M, E>>): Promise<void> => new Promise<void>(\n  (resolve, e) => Promise.all([\n    // Emit meta-event\n    emitMeta(EMetaEvents.EMIT)(eventMap, event, args),\n\n    ...[...(eventMap[event] || [])].map(\n      ([handler, unsubscribe]) => handler\n        && handler({ event, unsubscribe }, ...args)\n    )\n  ]).then(_ => resolve(), e)\n);\n\nexport type TEventParamsMap<M extends TEventMap> = {\n  [name in keyof M]: TLastParams<THandlerOf<M, name>>;\n};\n\n/**\n * Emit all events for a given event collection\n *\n * @param eventMap - event collection to emit events for\n *\n * @returns a function that emits all events from a collection with given arguments\n */\nexport const emitAll = <M extends TEventMap>(\n  eventMap: M\n) => (\n  eventArgs: TEventParamsMap<M>\n) => mapObject<M, Promise<void>>(\n  eventMap,\n  name => emit(eventMap)(name)(...eventArgs[name])\n);\n\nexport const emitMeta = <E extends keyof TMetaEvents>(event: E) => (\n  ...args: TLastParams<THandlerOf<TMetaEvents, E>>\n): Promise<void> => args[0] !== metaEvents\n  ? emit(metaEvents)(event)(...args)\n  : Promise.resolve();\n","import { emitMeta } from './emit';\nimport { doForAll, THandlersForAll } from './util';\nimport { TEventMap, TUnsubscribeHandlers } from './types';\nimport { EMetaEvents } from './meta-events';\n\nexport const unsubscribe = <M extends TEventMap>(\n  eventMap: M\n) => <E extends keyof M>(\n  event: E\n): TUnsubscribeHandlers<M, E> => (\n  ...handlers\n) => {\n  for (\n    const h of handlers.length > 0\n      ? handlers\n      : eventMap[event].keys()\n  ) if (event in eventMap)\n    // Emit meta-event (ignore promise)\n    emitMeta(EMetaEvents.UNSUBSCRIBE)(eventMap, event, h),\n    eventMap[event].delete(h);\n};\n\nexport const off = unsubscribe;\n\nexport const unsubscribeFromAll = <THandlersForAll> doForAll(unsubscribe);\n\nexport const offAll = unsubscribeFromAll;\n","import { unsubscribe } from './unsubscribe';\nimport { emitMeta } from './emit';\nimport { doForAll, THandlersForAll } from './util';\nimport { TEventMap, THandlerOf, TUnsubscribe } from './types';\nimport { EMetaEvents } from './meta-events';\n\nexport type TSubscriber<M extends TEventMap, N extends keyof M> = {\n  (handler: THandlerOf<M, N>): TUnsubscribe<N>;\n  (...handlers: Array<THandlerOf<M, N>>): TUnsubscribe<N>;\n};\n\ntype TSubscriberFactory<M extends TEventMap> = {\n  <E extends keyof M>(event: E): TSubscriber<M, E>;\n};\n\n/**\n * A subscriber factory\n *\n * @param eventMap - an event collection to subscribe to\n * @returns a function that subscribes handlers to a given event in a collection\n */\nexport const subscribe = <M extends TEventMap>(\n  eventMap: M\n): TSubscriberFactory<M> => <E extends keyof M>(\n  event: E\n): TSubscriber<M, E> => (...handlers: Array<THandlerOf<M, E>>) => {\n  const unsub = (\n    ...handlers: Array<THandlerOf<M, E>>\n  ) => () => unsubscribe(eventMap)(event)(...handlers);\n\n  return unsub(...handlers.map(handler => (\n    // Emit meta-event (ignore promise)\n    emitMeta(EMetaEvents.SUBSCRIBE)(eventMap, event, handler),\n    (eventMap[event] = eventMap[event] || new Map()).set(handler, unsub(handler)),\n    handler\n  )));\n};\n\nexport const on = subscribe;\n\n/**\n * A subscriber factory for all events of a given collection\n *\n * @param eventMap - an event collection to subscribe to\n * @returns a function that subscribes handlers to all events in the given event collection\n */\nexport const subscribeToAll = <THandlersForAll> doForAll(subscribe);\n\nexport const onAll = subscribeToAll;\n","import { mapObject, TDoAction } from './util';\nimport { emit } from './emit';\nimport { subscribe } from './subscribe';\nimport { unsubscribe } from './unsubscribe';\nimport { TEventMap, THandlerOf, TEventHandler, TLastParams } from './types';\n\ntype TEventHandlerFrom<H extends TEventHandler> = (...args: TLastParams<H>) => Promise<void>;\n\nexport type THandlerMap<M extends TEventMap> = {\n  [event in keyof M]: TEventHandlerFrom<THandlerOf<M, event>>;\n};\n\nexport type THandlersMap<M extends TEventMap> = {\n  [event in keyof M]: (...handlers: THandlerOf<M, event>[]) => void;\n};\n\nexport type TEventCollection<M extends TEventMap> = {\n  emit: THandlerMap<M>;\n  subscribe: THandlersMap<M>;\n  unsubscribe: THandlersMap<M>;\n};\n\nconst createCollection = <A extends TDoAction>(\n  action: A\n) => <M extends TEventMap>(\n  eventMap: M\n) => mapObject(\n  eventMap,\n  action(eventMap)\n);\n\n// TODO - remove type-casting\n\n/**\n * Create a namespaced event emitter collection\n * with each property of the collection corresponding to emitting a particular event\n *\n * @param eventMap - event collection to emit events for\n */\nexport const emitCollection = <{\n  <M extends TEventMap>(eventMap: M): THandlerMap<M>;\n}> createCollection(emit as TDoAction);\n\ntype THandlersMapper = {\n  <M extends TEventMap>(eventMap: M): THandlersMap<M>;\n};\n\n/**\n * Create a namespaced event subscriber collection\n * with each property of the collection corresponding to subscribing to a particular event\n *\n * @param eventMap - event collection to subscribe handlers for\n */\nexport const subscribeCollection = <THandlersMapper> createCollection(subscribe);\n\n/**\n * Create a namespaced event unsubscriber collection\n * with each property of the collection corresponding to unsubscribing from a particular event\n *\n * @param eventMap - event collection to unsubscribe handlers from\n */\nexport const unsubscribeCollection = <THandlersMapper> createCollection(unsubscribe);\n\n/**\n * Creates an OOP-style event collection\n *\n * @param eventMap - event map to create a collection from\n */\nexport const eventCollection = <M extends TEventMap>(\n  eventMap: M\n): TEventCollection<M> => ({\n  emit: emitCollection(eventMap),\n  subscribe: subscribeCollection(eventMap),\n  unsubscribe: unsubscribeCollection(eventMap),\n});\n","import { subscribe } from './subscribe';\nimport { TEventMap, THandlerOf, TLastParams } from './types';\n\n/**\n * Creates an event waiter for an event-map\n *\n * @param eventMap - an event-map to create a waiter for\n * @returns an event waiter\n */\nexport const wait = <M extends TEventMap>(\n  eventMap: M\n) =>\n/**\n * Wait for event to be emitted\n *\n * @param event - an event to wait for\n * @returns a promise that resolves as soon as the described event is emitted\n */\n<E extends keyof M>(\n  event: E\n) => new Promise<TLastParams<THandlerOf<M, E>>>(resolve =>\n  subscribe(eventMap)(event)((\n    (_, ...args: TLastParams<THandlerOf<M, E>>) => (\n      _.unsubscribe(),\n      resolve(args)\n    )\n  ) as THandlerOf<M, E>)\n);\n\n/**\n * Creates an event waiter factory for an event-map\n *\n * Same as `wait`, but in-harmony with the other methods\n * due to having an arity of 3.\n *\n * @param eventMap - an event-map to create a waiter for\n * @returns an event waiter factory\n */\nexport const harmonicWait = <M extends TEventMap>(\n  eventMap: M\n) =>\n/**\n * Wait for event to be emitted\n *\n * @param event - an event to wait for\n * @returns an event waiter that returns a promise\n */\n<E extends keyof M>(\n  event: E\n) =>\n/**\n * Wait for event to be emitted\n *\n * @returns a promise that resolves as soon as the described event is emitted\n */\n() => wait(eventMap)(event);\n","import { metaEvents, TMetaEvents } from './meta-events';\nimport { onAll } from './subscribe';\nimport { offAll } from './unsubscribe';\nimport { TEventMap, TEventContext, TEventHandler } from './types';\n\nconst onMeta = onAll(metaEvents);\nconst offMeta = offAll(metaEvents);\n\n/**\n * Default logging function\n */\nconst log = (\n  { event }: TEventContext<TMetaEvents>,\n  _map: TEventMap,\n  eventName: keyof TEventMap,\n  argsOrHandler: any[] | TEventHandler\n) => console.log(\n  // tslint:disable-next-line: no-magic-numbers - because these *are* magic\n  new Date().toJSON().substr(14, 9),\n\n  `[${event} \"${String(eventName)}\"] -`,\n\n  ...(Array.isArray(argsOrHandler)\n    ? argsOrHandler\n    : [argsOrHandler]\n  )\n);\n\nexport type TLogHandler = typeof log;\n\nexport interface IDebugOptions {\n  enable: boolean;\n  log?: TLogHandler;\n}\n\n/**\n * Enable or disable the debug mode.\n *\n * When debug mode is enabled - every event is logged to the console\n * with a timestamp and other information.\n *\n * @param enable - whether to enable the debug mode\n * - `true` to enable, `false` to disable\n */\nexport const debug = ({ enable, log: logEvent = log }: IDebugOptions) => (\n  enable ? onMeta : offMeta\n)(logEvent);\n","import { TEventMap, THandlerOf, TEventContext, TLastParams } from './types';\n\nexport const once = <\n  M extends TEventMap,\n  E extends keyof M\n>(handler: THandlerOf<M, E>) => (\n  _: TEventContext<M>,\n  ...args: TLastParams<THandlerOf<M, E>>\n) => (handler(_, ...args), _.unsubscribe());\n"],"names":["mapObject","obj","value","Object","keys","getOwnPropertySymbols","reduce","newObj","key","doForAll","action","eventMap","args","events","event","Map","set","metaEvents","_","_map","_event","_args","_handler","emit","Promise","resolve","e","all","emitMeta","_toConsumableArray","map","handler","unsubscribe","then","handlers","length","h","off","unsubscribeFromAll","offAll","subscribe","unsub","on","subscribeToAll","onAll","createCollection","emitCollection","subscribeCollection","unsubscribeCollection","wait","onMeta","offMeta","log","eventName","argsOrHandler","console","Date","toJSON","substr","String","Array","isArray","enable","eventArgs","name"],"mappings":"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"}