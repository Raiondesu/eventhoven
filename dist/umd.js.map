{"version":3,"file":"umd.js","sources":["../src/util.ts","../src/events.ts","../src/meta-events.ts","../src/emit.ts","../src/unsubscribe.ts","../src/subscribe.ts","../src/collections.ts","../src/all.ts","../src/debug.ts","../src/wait.ts","../src/once.ts"],"sourcesContent":["import { TEventMap } from './types';\n\n/**\n * Maps object values by their keys into a new object\n *\n * Generaly equivalent to `Array.prototype.map()`\n */\nexport const mapObject = <T extends object, R>(\n  obj: T,\n  value: (key: keyof T) => R\n) => (\n  <Array<keyof T>>\n  [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)]\n).reduce((newObj, key) => (\n  newObj[key] = value(key), newObj\n), <Record<keyof T, R>> {});\n\nexport type TDoAction<P extends any[] = any[], R = void> = <M extends TEventMap>(\n  eventMap: M\n) => <E extends keyof M>(\n  event: E\n) => (...args: P) => R;\n","import { mapObject } from './util';\nimport { TEventMap, TEventSignatures } from './types';\n\n/**\n * Creates an event collection based on handler templates\n *\n * @param events - an object with default handlers for events\n */\nexport const eventMap = <Events extends TEventSignatures>(\n  events: Events\n) => <TEventMap<Events>> mapObject(\n  events,\n  // Actually faster than `new Map([[events[event], () => {}]])`\n  // see https://jsperf.com/map-constructor-vs-set/1\n  event => new Map().set(events[event], () => {\n    /* make it impossible to unsubscribe from the default handler */\n  })\n);\n","import { eventMap } from './events';\nimport { TEventMap, TEventHandler } from './types';\n\nexport const enum EMetaEvents {\n  /**\n   * Emitted when any event is emitted, except itself\n   */\n  EMIT = 'EMIT',\n\n  /**\n   * Emitted when any event is subscribed to, except itself\n   */\n  SUBSCRIBE = 'SUBSCRIBE',\n\n  /**\n   * Emitted when any event is unsubscribed from, except itself\n   */\n  UNSUBSCRIBE = 'UNSUBSCRIBE',\n}\n\nexport const metaEvents = eventMap({\n  [EMetaEvents.EMIT](_, _map: TEventMap, _event: keyof TEventMap, _args: any[]) {},\n  [EMetaEvents.SUBSCRIBE](_, _map: TEventMap, _event: keyof TEventMap, _handler: TEventHandler) {},\n  [EMetaEvents.UNSUBSCRIBE](_, _map: TEventMap, _event: keyof TEventMap, _handler: TEventHandler) {},\n});\n\nexport type TMetaEvents = typeof metaEvents;\n","import { TMetaEvents, metaEvents, EMetaEvents } from './meta-events';\nimport { mapObject } from './util';\nimport { TEventMap, THandlerOf, TLastParams } from './types';\n\n/**\n * Event-emitter factory creator\n *\n * Creates an emitter factory for specific events.\n *\n * @param eventMap - an event collection to create an emitter for\n */\nexport const emit = <M extends TEventMap>(\n  eventMap: M\n) =>\n/**\n * Emitter factory for a specific event collection\n *\n * Creates an emitter for a specific event\n *\n * @param event - the name of the event to emit\n */\n<E extends keyof M>(event: E) =>\n/**\n * Emits an event with proper arguments\n */\n(...args: TLastParams<THandlerOf<M, E>>): Promise<void> => new Promise<void>(\n  (resolve, e) => Promise.all([\n    // Emit meta-event\n    emitMeta(EMetaEvents.EMIT)(eventMap, event, args),\n\n    ...[...(eventMap[event] || [])].map(\n      ([handler, unsubscribe]) => handler\n        && handler({ event, unsubscribe }, ...args)\n    )\n  ]).then(_ => resolve(), e)\n);\n\n/**\n * Emits a meta-event\n *\n * @param event - a meta-event to emit\n */\nexport const emitMeta = <E extends EMetaEvents>(event: E) => (\n  ...args: TLastParams<THandlerOf<TMetaEvents, E>>\n): Promise<void> => args[0] !== metaEvents\n  ? emit(metaEvents)(event)(...args)\n  : Promise.resolve();\n","import { emitMeta } from './emit';\nimport { TEventMap, TUnsubscribeHandlers } from './types';\nimport { EMetaEvents } from './meta-events';\n\nexport const unsubscribe = <M extends TEventMap>(\n  eventMap: M\n) => <E extends keyof M>(\n  event: E\n): TUnsubscribeHandlers<M, E> => (\n  ...handlers\n) => {\n  if (event in eventMap) for (\n    const h of handlers.length > 0\n      ? handlers\n      : eventMap[event].keys()\n  )\n    // Emit meta-event (ignore promise)\n    emitMeta(EMetaEvents.UNSUBSCRIBE)(eventMap, event, h),\n    eventMap[event].delete(h);\n};\n\nexport const off = unsubscribe;\n","import { unsubscribe } from './unsubscribe';\nimport { emitMeta } from './emit';\nimport { TEventMap, THandlerOf, TUnsubscribe } from './types';\nimport { EMetaEvents } from './meta-events';\n\nexport type TSubscriber<M extends TEventMap, N extends keyof M> = {\n  (handler: THandlerOf<M, N>): TUnsubscribe<N>;\n  (...handlers: Array<THandlerOf<M, N>>): TUnsubscribe<N>;\n};\n\ntype TSubscriberFactory<M extends TEventMap> = {\n  <E extends keyof M>(event: E): TSubscriber<M, E>;\n};\n\n/**\n * A subscriber factory\n *\n * @param eventMap - an event collection to subscribe to\n * @returns a function that subscribes handlers to a given event in a collection\n */\nexport const subscribe = <M extends TEventMap>(\n  eventMap: M\n): TSubscriberFactory<M> => <E extends keyof M>(\n  event: E\n): TSubscriber<M, E> => (...handlers: Array<THandlerOf<M, E>>) => {\n  const unsub = (\n    ...handlers: Array<THandlerOf<M, E>>\n  ) => () => unsubscribe(eventMap)(event)(...handlers);\n\n  return unsub(...handlers.map(handler => (\n    // Emit meta-event (ignore promise)\n    emitMeta(EMetaEvents.SUBSCRIBE)(eventMap, event, handler),\n    event in eventMap && eventMap[event].set(handler, unsub(handler)),\n    handler\n  )));\n};\n\nexport const on = subscribe;\n","import { mapObject, TDoAction } from './util';\nimport { emit } from './emit';\nimport { subscribe } from './subscribe';\nimport { unsubscribe } from './unsubscribe';\nimport { TEventMap, THandlerOf, TEventHandler, TLastParams } from './types';\n\ntype TEventHandlerFrom<H extends TEventHandler> = (...args: TLastParams<H>) => Promise<void>;\n\nexport type THandlerMap<M extends TEventMap> = {\n  [event in keyof M]: TEventHandlerFrom<THandlerOf<M, event>>;\n};\n\nexport type THandlersMap<M extends TEventMap> = {\n  [event in keyof M]: (...handlers: THandlerOf<M, event>[]) => void;\n};\n\nexport type TEventCollection<M extends TEventMap> = {\n  emit: THandlerMap<M>;\n  subscribe: THandlersMap<M>;\n  unsubscribe: THandlersMap<M>;\n};\n\nconst createCollection = <A extends TDoAction>(\n  action: A\n) => <M extends TEventMap>(\n  eventMap: M\n) => mapObject(\n  eventMap,\n  action(eventMap)\n);\n\n// TODO - remove type-casting\n\n/**\n * Create a namespaced event emitter collection\n * with each property of the collection corresponding to emitting a particular event\n *\n * @param eventMap - event collection to emit events for\n */\nexport const emitCollection = <{\n  <M extends TEventMap>(eventMap: M): THandlerMap<M>;\n}> createCollection(emit as TDoAction);\n\ntype THandlersMapper = {\n  <M extends TEventMap>(eventMap: M): THandlersMap<M>;\n};\n\n/**\n * Create a namespaced event subscriber collection\n * with each property of the collection corresponding to subscribing to a particular event\n *\n * @param eventMap - event collection to subscribe handlers for\n */\nexport const subscribeCollection = <THandlersMapper> createCollection(subscribe);\n\n/**\n * Create a namespaced event unsubscriber collection\n * with each property of the collection corresponding to unsubscribing from a particular event\n *\n * @param eventMap - event collection to unsubscribe handlers from\n */\nexport const unsubscribeCollection = <THandlersMapper> createCollection(unsubscribe);\n\n/**\n * Creates an OOP-style event collection\n *\n * @param eventMap - event map to create a collection from\n */\nexport const eventCollection = <M extends TEventMap>(\n  eventMap: M\n): TEventCollection<M> => ({\n  emit: emitCollection(eventMap),\n  subscribe: subscribeCollection(eventMap),\n  unsubscribe: unsubscribeCollection(eventMap),\n});\n","import { mapObject, TDoAction } from './util';\nimport { TEventMap, THandlerOf, TLastParams } from './types';\nimport { emit } from './emit';\nimport { subscribe } from './subscribe';\nimport { unsubscribe } from './unsubscribe';\n\n/**\n * A `do`-er factory\n *\n * Applies a specified action for all events in a collection\n *\n * @param action - an action to apply\n */\nconst doForAll = <A extends TDoAction>(\n  action: A\n) => <M extends TEventMap>(\n  eventMap: M\n) => (\n  ...args: A extends TDoAction<infer P> ? P : any[]\n) => {\n  mapObject(eventMap, key => action(eventMap)(key)(...args));\n};\n\nexport type THandlersForAll = {\n  <M extends TEventMap>(eventMap: M): {\n    (handler: THandlerOf<M>): void;\n    (...handlers: THandlerOf<M>[]): void;\n  };\n};\n\nexport type TEventParamsMap<M extends TEventMap> = {\n  [name in keyof M]: TLastParams<THandlerOf<M, name>>;\n};\n\n/**\n * Emit all events for a given event collection\n *\n * @param eventMap - event collection to emit events for\n *\n * @returns a function that emits all events from a collection with given arguments\n */\nexport const emitAll = <M extends TEventMap>(\n  eventMap: M\n) => (\n  eventArgs: TEventParamsMap<M>\n) => mapObject<M, Promise<void>>(\n  eventMap,\n  name => emit(eventMap)(name)(...eventArgs[name])\n);\n\n/**\n * A subscriber factory for all events of a given collection\n *\n * @param eventMap - an event collection to subscribe to\n * @returns a function that subscribes handlers to all events in the given event collection\n */\nexport const subscribeToAll = <THandlersForAll> doForAll(subscribe);\nexport const onAll = subscribeToAll;\n\nexport const unsubscribeFromAll = <THandlersForAll> doForAll(unsubscribe);\nexport const offAll = unsubscribeFromAll;\n","import { metaEvents, TMetaEvents } from './meta-events';\nimport { onAll, offAll } from './all';\nimport { TEventMap, TEventContext, TEventHandler } from './types';\n\nconst onMeta = onAll(metaEvents);\nconst offMeta = offAll(metaEvents);\n\n/**\n * Default logging function\n */\nconst log = (\n  { event }: TEventContext<TMetaEvents>,\n  map: TEventMap,\n  eventName: keyof TEventMap,\n  argsOrHandler: any[] | TEventHandler\n) => console.log(\n  // tslint:disable-next-line: no-magic-numbers - because these *are* magic\n  new Date().toJSON().substr(14, 9),\n\n  `[${event} \"${String(eventName)}\"${eventName in map ? '' : ' (INVALID)'}] -`,\n\n  ...(Array.isArray(argsOrHandler)\n    ? argsOrHandler\n    : [argsOrHandler]\n  )\n);\n\nexport type TLogHandler = typeof log;\n\nexport interface IDebugOptions {\n  enable: boolean;\n  log?: TLogHandler;\n}\n\n/**\n * Enable or disable the debug mode.\n *\n * When debug mode is enabled - every event is logged to the console\n * with a timestamp and other information.\n *\n * @param enable - whether to enable the debug mode\n * - `true` to enable, `false` to disable\n *\n * @param [log] - a custom logging function\n */\nexport const debug = ({ enable, log: logEvent = log }: IDebugOptions) => (\n  enable ? onMeta : offMeta\n)(logEvent);\n","import { subscribe } from './subscribe';\nimport { TEventMap, THandlerOf, TLastParams } from './types';\n\n/**\n * Creates an event waiter for an event-map\n *\n * @param eventMap - an event-map to create a waiter for\n * @returns an event waiter\n */\nexport const wait = <M extends TEventMap>(\n  eventMap: M\n) =>\n/**\n * Wait for event to be emitted\n *\n * @param event - an event to wait for\n * @returns a promise that resolves as soon as the described event is emitted\n */\n<E extends keyof M>(\n  event: E\n) => new Promise<TLastParams<THandlerOf<M, E>>>(resolve =>\n  subscribe(eventMap)(event)((\n    (_, ...args: TLastParams<THandlerOf<M, E>>) => (\n      _.unsubscribe(),\n      resolve(args)\n    )\n  ) as THandlerOf<M, E>)\n);\n\n/**\n * Creates an event waiter factory for an event-map\n *\n * Same as `wait`, but in-harmony with the other methods\n * due to having an arity of 3.\n *\n * @param eventMap - an event-map to create a waiter for\n * @returns an event waiter factory\n */\nexport const harmonicWait = <M extends TEventMap>(\n  eventMap: M\n) =>\n/**\n * Wait for event to be emitted\n *\n * @param event - an event to wait for\n * @returns an event waiter that returns a promise\n */\n<E extends keyof M>(\n  event: E\n) =>\n/**\n * Wait for event to be emitted\n *\n * @returns a promise that resolves as soon as the described event is emitted\n */\n() => wait(eventMap)(event);\n","import { TEventMap, THandlerOf, TEventContext, TLastParams } from './types';\n\n/**\n * Makes a handler to be called only once,\n * by unsubscribing it right at its execution\n *\n * @param handler - a handler to transform\n *\n * @returns a transformed handler\n */\nexport const once = <\n  M extends TEventMap,\n  E extends keyof M\n>(handler: THandlerOf<M, E>) => (\n  _: TEventContext<M>,\n  ...args: TLastParams<THandlerOf<M, E>>\n) => <\n  ReturnType<THandlerOf<M, E>>\n> (_.unsubscribe(), handler(_, ...args));\n"],"names":["mapObject","obj","value","Object","keys","getOwnPropertySymbols","reduce","newObj","key","eventMap","events","event","Map","set","metaEvents","_","_map","_event","_args","_handler","emit","args","Promise","resolve","e","all","emitMeta","_toConsumableArray","map","handler","unsubscribe","then","handlers","length","h","off","subscribe","unsub","on","createCollection","action","emitCollection","subscribeCollection","unsubscribeCollection","doForAll","subscribeToAll","onAll","unsubscribeFromAll","offAll","onMeta","offMeta","log","eventName","argsOrHandler","console","Date","toJSON","substr","String","Array","isArray","wait","enable","eventArgs","name"],"mappings":"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"}